:author: Tony Kay
:revdate: September 19, 2018
:revnumber: 1
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 2
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:scriptsdir: js

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

= Internationalization [[I18N]]

WARNING: I took a rough pass at updating this documentation, but nothing has been testing in a live app.

Fulcro has had internationalization support since inception. That original support worked well from the call-site; however,
many lessons were learned about storing, transmitting, and structuring the actual data.

The support:

* The ability to write UI strings in a default language/locale in the code. These are the defaults that are shown on
the UI if no translation is available.
* Supports string extraction from the compiled UI code.
** The translator can use tools like POEdit to generate translation files
* Leverages normal application state as the location to house loaded translations.
* Allows the server to serve new locale translations via a normal query.
* Includes server tools to directly read locales from GNU gettext PO files (no more code generation).
* Supports a pluggable message formatting system.

== The Core API

The following functions and macros make up the core of the API:

[[Horizontal]]
`tr`:: A macro that looks up the given string and returns the translation based on the current locale.
`trc`:: A macro that looks up the given string with a translation context (note to the translator) and returns the translation based on the current locale.
`trf`:: A macro that looks up the given string, and passes it and additional options through to a message formatter.
`tr-unsafe`:: All three of the above have an `unsafe` version. The main three require literal strings for their arguments
because string extraction won't work correctly otherwise. The unsafe versions are for situations where this is insufficient,
but you still need some kind of marker to let you know where translation might be needed.

Examples:

[source]
-----
(tr "Hello") ; might return "Hola"
(trc "Abbreviation for Male" "M") ; might return M (translator sees the other string as a note)
(trf "Hi {name}" {:name n}) ; passes a translated version of "Hi {name}" to the message formatter along with the options map.

(tr-unsafe current-selection) ; allows a non-literal to be sent through lookup. The possible values of current-selection will need to be extracted elsewhere.
-----

=== Dealing with "Unsafe" Usage

When you use an `unsafe` variant, it simply means that GNU gettext is not going to be able to extract a string
(because extraction is a static analysis of compiled code). One approach
is simply to make notes for your translator. That approach isn't very scalable.

Usually, this comes up when you have something like a dropdown that needs to display translated strings. Another approach
is to simply call `tr` on the literal values in some unreachable code. Whitespace optimizations will *not* remove
these, so extraction will find them, whereas advanced optimizations will see that they are not directly called and
will remove them:

[source]
-----
(defn do-not-call []
  (tr "Yes") ; these are here for extraction only
  (tr "No"))

(def options {:yes "Yes" :no "No"})

(defn render-option [o]
   (tr-unsafe (get options o)))
-----

WARNING: It is tempting to wrap the values of `options` in `tr`, but that is a bad idea.

[source]
-----
(def options {:yes (tr "Yes") :no (tr "No")}) ; BAD IDEA!
-----

This is a problem because your program can break for unexpected reasons. If you changed the locale before
that code executed then your `options` map might contain the *translations* instead of the default locale keys
(e.g. `{:yes "Oi" :no "Non"}`) which are *not* the correct keys for the later calls to `tr`!

Remember that your string extraction is done against the real string you embed on the UI (your default locale), and
those become the lookup keys for runtime. If you change those lookup keys based on the runtime locale, things will
break.

== Polyfills and Message Formatters

Fulcro's i18n support is designed to make it easy to code and extract translatable strings in your UI. It is not, itself,
interested in doing message, number, currency, or date formatting. There are plenty of libraries, including Google Closure,
that can already fill that role.

The easiest pair to use for both server and client rendering are the FormatJS (client) and IBM ICU library (server). These
two libraries follow the same formatting standards, and give good isomorphic rendering support.

Fulcro does one central task: it takes a string in the UI, looks up an alternate string (based on the locale) from a PO
file, and pushes that alternate string through the rest of the i18n processing chain (which you define).

The macro:

[source]
-----
(tr "Hello")
-----

will use the combination of the current locale and loaded locale data to return the correct translation for "Hello". A
call to:

[source]
-----
(trf "Hi {name}" {:name "Joe"})
-----

will look up "Hi {name}" in the translations, find something like "Hola, {name}", and will then pass that translation
through to a message formatter that can substitute the supplied parameters for the placeholders.

For this to work you must load whatever polyfills and tools you need for message formatting, and then install your
message formatter into Fulcro's i18n system.

== Configuring I18N

Your first step is to define a function that can format messages. The easiest way to do this is to use the
`com.fulcrologic.fulcro-i18n.icu-formatter/format` support. This requires the following:

* Add `com.ibm.icu/icu4j       {:mvn/version "66.1"}` to your deps.edn (or equiv).
* Add `"intl-messageformat": "^9.3.11"` to your package.json

and then use it as your formatter.
The message formatter receives a single map with `i18n` namespaced keys. `locale` will be a keyword, `localized-format-string`
will be the *already-translated* base string, and the `format-options` will be whatever map was passed along to `trf`.

Fulcro's i18n uses `shared` properties to communicate the current locale, message formatter, and translations to the
UI components.

When creating your client:

. Include these options on the client:
+
[source]
-----
(ns appns
  (:require
    [com.fulcrologic.fulcro.application :as app]
    [com.fulcrologic.fulcro-i18n.icu-formatter :as icu]
    [com.fulcrologic.fulcro-i18n.i18n :as i18n]))

(defonce app (app/fulcro-app
  {:shared    {::i18n/message-formatter icu/format}
   :shared-fn ::i18n/current-locale}))
-----
+
. Your `Root` UI component *MUST* query for `::i18n/current-locale` and should also set the initial locale in
application state. The `shared-fn` extracts denormalized data from your UI root's props. This also sets the "default" locale of your application.

== Setting the "Default Locale" [[DefaultLocale]]

Your root component should place a locale in the `::i18n/current-locale`. This is normalized state, so the root
component query should join on the `Locale` component:

[source]
-----
(defsc Root [this props]
  {:query         [{::i18n/current-locale (comp/get-query i18n/Locale)}]
   :initial-state (fn [p] {::i18n/current-locale (comp/get-initial-state i18n/Locale {:locale :en :translations {}})})}
-----

== Accessing the Current Locale

Shared properties are visible to all UI components via `(comp/shared this)`. You will find the property `::i18n/current-locale`
in there as well as your message formatter.

Mutations have the state database, and can simply look for the top-level key `::i18n/current-locale`.

== Changing the Locale

The are a few aspects to changing the locale:

. Ensuring that the locale's translations are loaded.
. Changing the locale in app state.
. Force rendering the entire UI to refresh displayed strings.

All of these tasks are handled for you by the `i18n/change-locale` mutation, which you can embed anywhere in your
application:

[source]
-----
(comp/transact! this `[(i18n/change-locale {:locale :es})])
-----

There is a pre-built <<LocaleSelector, locale selector>> for your convenience.

== Responding to Locale Loading Queries on Your Server [[ServingLocales]]

Of course, triggering a change locale that tries to load missing translations will fail if your server doesn't respond
to the query! Fortunately, configuring your server to serve these is very easy!

. Place all of your `.po` files on disk or in your applications classpath. The names of the PO files must be `LOCALE.po`,
where `LOCALE` matches the locale keyword (minus the `:`), case sensitive.
. Add a root query like this:

[source]
-----
(defresolver locale-resolver [env {:keys [locale]}]
  {::pc/output [::i18n/translations]}
  (if-let [locale (i18n/load-locale "po-files" locale)]
    locale
    nil))
-----

of course you can augment this to log errors or whatever else you want it to do. The `"po-files"` argument is the location
of the po files. If it is a relative path, the resources will be searched (CLASSPATH). If it is an absolute path, then
the local disk will be searched instead.

== Extracting Strings

You can extract the strings from your UI for translation using GNU's CLI utility `xgettext` (available via Brew, etc).

The steps are:

. Compile your application with whitespace optimizations.
. Run this on the resulting js file:
+
[source]
-----
$ xgettext --from-code=UTF-8 --debug -k -ktr:1 -ktrc:1c,2 -ktrf:1 -o messages.pot application.js
-----

== Generating Locale Translation Files

See GNU's gettext documentation for full details. Here are some basics:

Applications like https://poedit.net/[POEdit] can be used to generate a new locale from the `messages.pot` in the prior step.
Once you have the output (a file like `es.po`) you simply copy that to your server's PO directory as described
in the section on <<ServingLocales, serving locales>>.

When your application changes, you want to keep the existing translations. The gettext utility `msgmerge` is
useful for this. It takes the new `messages.pot` file and old PO files and generates new PO files that include
as many of the old translations as possible. This allows your translator to just deal with the changes.

Something like this will update a PO file:

[source]
-----
$ msgmerge --force-po --no-wrap -U es.po messages.pot
-----

Again send that off to your translator, and when they return it place the updated PO file on your server.

== Prebuilt Locale Selector [[LocaleSelector]]

The i18n support comes with a convenient `LocaleSelector` component that you can use. You can, of course, write your
own and invoke the `change-locale` mutation, but the pre-written one can be used as follows:

[source]
-----
(defsc Root [this {:keys [locale-selector]}]
  {:query         [{:locale-selector (comp/get-query i18n/LocaleSelector)}
                   {::i18n/current-locale (comp/get-query i18n/Locale)}]
   :initial-state (fn [p] {::i18n/current-locale (comp/get-initial-state Locale {:locale :en :translations {}})
                           :locale-selector      (comp/get-initial-state LocaleSelector
                                                   {:locales [(comp/get-initial-state Locale {:locale :en :name "English"})
                                                              (comp/get-initial-state Locale {:locale :es :name "Espanol"})
                                                              (comp/get-initial-state Locale {:locale :de :name "Deutsch"})]}}}
  (dom/div
    (i18n/ui-locale-selector locale-selector)
    ...))
-----

The initialization parameters are a list of the locales that
are available on your server. You could, of course, load these at startup and fill out app state; however,
since you have to know what locales you're supporting in order to work with translators, it's probably just
as easy to hard-code them.

Each locale must be given a name (UTF8) to be show in the resulting select drop-down. This renders
as an HTML select with the CSS class "fulcro$i18n$locale_selector".

== Server-Side Rendering

Server side rendering of the default locale require no additinal code, because the strings
you need are already the strings in the code. If you wish to pre-render a page using a
specific locale then there is just a little bit more to do.

The steps are:

. Load the locale from a po file.
. Generate initial db to embed in the HTML that contains the proper normalized `::i18n/current-locale`.
. Use `i18n/with-locale` to wrap the server render.

[source]
-----
(defn message-formatter ...) ; a server-side message formatter, e.g. use IBM's ICU library

(defn generate-index-html [state-db app-html]
  (let [initial-state-script (ssr/initial-state->script-tag state-db)]
    (str "<html><head>" initial-state-script "</head><body><div id='app'>" app-html "</div></body></html>")))

(defn index-html []
  (let [initial-tree     (comp/get-initial-state Root {})
        es-locale        (i18n/load-locale "po-directory" :es)
        tree-with-locale (assoc initial-tree ::i18n/current-locale es-locale)
        initial-db       (ssr/build-initial-state tree-with-locale Root)
        ui-root          (comp/factory Root)]
    (generate-index-html initial-db
      (i18n/with-locale message-formatter es-locale
        (dom/render-to-str (ui-root tree-with-locale))))))
-----
